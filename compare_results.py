import glob
import os
import pandas as pd
import matplotlib.pyplot as plt

# Looks for metrics_*.csv generated by simulation.py (export metrics).
FILES = sorted(glob.glob("metrics_*.csv"))

if not FILES:
    raise FileNotFoundError(
        "No metrics_*.csv found in the current folder. "
        "Run the simulation and export metrics to generate them."
    )

def pretty(path: str) -> str:
    base = os.path.splitext(os.path.basename(path))[0]
    return base.replace("metrics_", "").replace("_", " ").title()

from typing import Optional, List

def find_col(df: pd.DataFrame, candidates: List[str]) -> Optional[str]:

    """Return the first column name present in df from candidates."""
    for c in candidates:
        if c in df.columns:
            return c
    return None

def last_value(df: pd.DataFrame, col: str):
    if col is None or col not in df.columns or df.empty:
        return None
    return df[col].iloc[-1]

def safe_mean(df: pd.DataFrame, col: str):
    if col is None or col not in df.columns or df.empty:
        return None
    return df[col].mean()

def safe_quantile(df: pd.DataFrame, col: str, q: float):
    if col is None or col not in df.columns or df.empty:
        return None
    return df[col].quantile(q)

def safe_max(df: pd.DataFrame, col: str):
    if col is None or col not in df.columns or df.empty:
        return None
    return df[col].max()

# Load files
dfs: dict[str, pd.DataFrame] = {f: pd.read_csv(f) for f in FILES}

# Common column candidates (handles small naming differences)
TIME_COLS = ["time_s", "time", "t", "seconds"]
TOTAL_QUEUE_COLS = ["total_queue", "queue_total", "totalQueue", "queue"]
VIP_QUEUE_COLS = ["vip_queue", "queue_vip", "vipQueue"]
SWITCHES_COLS = ["switches", "phase_switches", "num_switches", "switch_count"]
THROUGHPUT_COLS = ["cars_passed", "cars_served", "throughput", "total_passed", "passed_cars"]
WAIT_COLS = ["avg_wait_s", "mean_wait_s", "avg_delay_s", "mean_delay_s", "waiting_time_s", "delay_s", "total_wait_s"]

# ---------------------------
# Plot 1: Total queue over time
# ---------------------------
plt.figure()
any_plotted = False

for f, df in dfs.items():
    tcol = find_col(df, TIME_COLS)
    qcol = find_col(df, TOTAL_QUEUE_COLS)
    if tcol and qcol:
        plt.plot(df[tcol], df[qcol], label=pretty(f))
        any_plotted = True

plt.xlabel("Time (s)")
plt.ylabel("Total queue length")
plt.title("Controller comparison: Total queue over time")
if any_plotted:
    plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("comparison_plot_total_queue.png", dpi=200)
plt.show()

# ---------------------------
# Plot 2: VIP queue over time (only if present)
# ---------------------------
plt.figure()
any_plotted = False

for f, df in dfs.items():
    tcol = find_col(df, TIME_COLS)
    vcol = find_col(df, VIP_QUEUE_COLS)
    if tcol and vcol:
        plt.plot(df[tcol], df[vcol], label=pretty(f))
        any_plotted = True

plt.xlabel("Time (s)")
plt.ylabel("VIP queue length")
plt.title("Controller comparison: VIP queue over time")
if any_plotted:
    plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig("comparison_plot_vip_queue.png", dpi=200)
plt.show()

# ---------------------------
# Summary table
# ---------------------------
rows = []
for f, df in dfs.items():
    tcol = find_col(df, TIME_COLS)
    qcol = find_col(df, TOTAL_QUEUE_COLS)
    vcol = find_col(df, VIP_QUEUE_COLS)
    scol = find_col(df, SWITCHES_COLS)
    thrcol = find_col(df, THROUGHPUT_COLS)
    wcol = find_col(df, WAIT_COLS)

    row = {
        "controller": pretty(f),
        "avg_total_queue": safe_mean(df, qcol),
        "p95_total_queue": safe_quantile(df, qcol, 0.95),
        "max_total_queue": safe_max(df, qcol),
        "avg_vip_queue": safe_mean(df, vcol),
        # if switches is cumulative, last_value makes sense; if it's per-step, mean is also useful:
        "switches_last": last_value(df, scol),
        "switches_mean": safe_mean(df, scol),
    }

    # Throughput: prefer last value (typical for cumulative counters)
    if thrcol:
        row["throughput_last"] = last_value(df, thrcol)

    # Waiting/delay: if total_wait_s is total (cumulative) use last; else use mean
    if wcol:
        if "total" in wcol:
            row["total_wait_s_last"] = last_value(df, wcol)
        else:
            row["avg_wait_s_mean"] = safe_mean(df, wcol)

    # Duration (helps sanity-check all controllers ran same length)
    if tcol:
        row["duration_s"] = last_value(df, tcol)

    rows.append(row)

summary = pd.DataFrame(rows)

# Sort by avg_total_queue (lower is better), then p95
sort_cols = [c for c in ["avg_total_queue", "p95_total_queue"] if c in summary.columns]
if sort_cols:
    summary = summary.sort_values(sort_cols, na_position="last")

pd.set_option("display.max_columns", 200)
pd.set_option("display.width", 140)

print("\nSummary (lower avg_total_queue is better):")
print(summary.to_string(index=False))

# Save summary for report
summary.to_csv("comparison_summary.csv", index=False)
print("\nSaved: comparison_summary.csv")
print("Saved: comparison_plot_total_queue.png")
print("Saved: comparison_plot_vip_queue.png (if VIP queue existed)")
